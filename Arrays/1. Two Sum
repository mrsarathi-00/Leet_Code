1. Two Sum

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.

Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]
Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]


Constraints:

2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
Only one valid answer exists.


//////////////////////////////////////////////////////////////////////////////////////// BRUTE FORCE ////////////////////////////////////////////////////////////////////////////////////////

class Solution {
    public int[] twoSum(int[] nums, int target) {
        // Iterate through each element in the array
        for (int i = 0; i < nums.length; i++) {
            // For each element, check the rest of the elements that come after it
            for (int j = i + 1; j < nums.length; j++) {
                // Check if the sum of nums[i] and nums[j] equals the target
                if (nums[i] + nums[j] == target) {
                    // If so, return their indices
                    return new int[]{i, j};
                }
            }
        }
        // If no such pair is found, return an empty array
        return new int[]{};
    }
}

//////////////////////////////////////////////////////////////////////////////////////// OPTIMAL ////////////////////////////////////////////////////////////////////////////////////////

class Solution {
    public int[] twoSum(int[] nums, int target) {
        // Create a HashMap to store the number and its index
        Map<Integer, Integer> map = new HashMap<>();

        // Iterate through the array
        for (int i = 0; i < nums.length; i++) {
            // Calculate the complement that would sum to the target
            int cmp = target - nums[i];

            // Check if the complement is already in the map
            if (map.containsKey(cmp)) {
                // If found, return the indices of the complement and the current number
                return new int[]{map.get(cmp), i};
            }

            // Otherwise, store the current number and its index in the map
            map.put(nums[i], i);
        }

        // If no solution is found (although the problem guarantees one), return an empty array
        return new int[]{};
    }
}

